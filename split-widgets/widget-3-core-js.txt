<script>
// CRITICAL FIX: Define YouTube player event callbacks BEFORE DOMContentLoaded
// This prevents race condition where player tries to use undefined callbacks

// YouTube Player Event Handlers - MUST be defined before player creation
window.onPlayerReady = function(event) {
  console.log('‚úÖ YouTube Player Ready!');

  // CRITICAL FIX: Use event.target to get the player object
  // The player in event.target is guaranteed to be ready
  window.player = event.target;
  window.playerReady = true;

  // Set volume (now player is guaranteed to exist)
  if (window.volume !== undefined) {
    window.player.setVolume(window.volume);
    console.log('üîä Volume set to:', window.volume);
  } else {
    window.player.setVolume(70); // Default volume
    console.log('üîä Volume set to default: 70');
  }

  const songs = window.getCurrentSongs();
  console.log('üìã Songs in current playlist:', songs.length);
  if (songs.length > 0) {
    console.log('üéµ Auto-selecting first song...');
    window.selectSong(0);
    window.updateStickyControlsInfo();
  } else {
    console.log('‚ö†Ô∏è No songs available to auto-select');
  }
};

window.onPlayerStateChange = function(event) {
  if (event.data === YT.PlayerState.PLAYING) {
    window.isPlaying = true;
    window.playIcon.style.display = 'none';
    window.pauseIcon.style.display = 'block';
    window.updateAllPlayButtons('pause');
    window.updateVisualizerState();
    window.startProgressUpdater();

    // Update Media Session state
    if ('mediaSession' in navigator) {
      navigator.mediaSession.playbackState = 'playing';
    }
  } else if (event.data === YT.PlayerState.PAUSED) {
    window.isPlaying = false;
    window.playIcon.style.display = 'block';
    window.pauseIcon.style.display = 'none';
    window.updateAllPlayButtons('play');
    window.updateVisualizerState();
    window.stopProgressUpdater();

    // Update Media Session state
    if ('mediaSession' in navigator) {
      navigator.mediaSession.playbackState = 'paused';
    }
  } else if (event.data === YT.PlayerState.ENDED) {
    window.handleSongEnd();
  }
};

// YouTube Player Initialization - Define callback BEFORE DOMContentLoaded
// This ensures the callback exists when YouTube API finishes loading
var ytPlayerReadyToInit = false;
var domIsReady = false;

window.onYouTubeIframeAPIReady = function() {
  console.log('‚úÖ YouTube API loaded via callback');
  ytPlayerReadyToInit = true;
  initYouTubePlayerWhenReady();
};

// CRITICAL FIX: Check if YouTube API already loaded
// If YT object exists, the API loaded before we defined the callback
if (typeof YT !== 'undefined' && YT.Player) {
  console.log('‚úÖ YouTube API already loaded - initializing immediately');
  ytPlayerReadyToInit = true;
}

function initYouTubePlayerWhenReady() {
  if (ytPlayerReadyToInit && domIsReady && document.getElementById('player')) {
    console.log('üé¨ Creating YouTube player...');
    try {
      window.player = new YT.Player('player', {
        height: '100%',
        width: '100%',
        videoId: '',
        playerVars: {
          'autoplay': 0,
          'controls': 0,
          'rel': 0,
          'showinfo': 0,
          'modestbranding': 1,
          'playsinline': 1
        },
        events: {
          'onReady': window.onPlayerReady,
          'onStateChange': window.onPlayerStateChange
        }
      });
      console.log('‚úÖ YouTube player created successfully');
    } catch (error) {
      console.error('‚ùå Error creating YouTube player:', error);
    }
  } else {
    console.log('‚è≥ Waiting... YT Ready:', ytPlayerReadyToInit, '| DOM Ready:', domIsReady, '| Player div exists:', !!document.getElementById('player'));
  }
}

// Wait for DOM to be ready before accessing elements
document.addEventListener('DOMContentLoaded', function() {
domIsReady = true;
console.log('‚úÖ DOM Ready - attempting player initialization...');
initYouTubePlayerWhenReady();

 // Firebase Configuration
 const firebaseConfig = {
 apiKey: "AIzaSyDPjVCn59pOyBUVW0vy0e5gAmbvunR8Eaw",
 authDomain: "music-player-library.firebaseapp.com",
 databaseURL: "https://music-player-library-default-rtdb.firebaseio.com",
 projectId: "music-player-library",
 storageBucket: "music-player-library.firebasestorage.app",
 messagingSenderId: "1021984826826",
 appId: "1:1021984826826:web:b24eaa21402b5a00485b33",
 measurementId: "G-NRMYDTH8BG"
};

 // Initialize Firebase
 window.database = null;
 window.firebaseAvailable = false;

 try {
 firebase.initializeApp(firebaseConfig);
 window.database = firebase.database();
 window.firebaseAvailable = true;
 console.log('‚úì Firebase connected - Community library active!');
 } catch (e) {
 console.log('‚ö†Ô∏è Firebase unavailable - Using localStorage fallback');
 window.firebaseAvailable = false;
 }

 // YouTube API Configuration
 const YOUTUBE_API_KEY = 'AIzaSyBijIimhG2s_uzGQybB13Iw0SQxwLTwQ4Y';
 const YOUTUBE_API_BASE = 'https://www.googleapis.com/youtube/v3';

 // Data structures
 window.playlists = [];
 window.playlistLibrary = [];
 window.currentPlaylistIndex = 0;
 window.currentSongIndex = 0;
 window.isPlaying = false;
 window.isShuffled = false;
 window.repeatMode = 0;
 window.volume = 70;
 window.isMuted = false;
 window.carouselOffset = 0;

 // Settings
 window.settings = {
 stickyControls: true,
 visualizer: true,
 backgroundAnim: true,
 floatingPlayer: false
 };

 // YouTube Player
 window.player = null;
 window.playerReady = false;
 window.progressInterval = null;

 // Floating Player State
 window.floatingPlayerActive = false;
 window.isDragging = false;
 window.dragOffsetX = 0;
 window.dragOffsetY = 0;
 window.popoutWindow = null;

 // DOM Elements
 window.playPauseBtn = document.getElementById('playPauseBtn');
 window.playIcon = document.getElementById('playIcon');
 window.pauseIcon = document.getElementById('pauseIcon');
 window.prevBtn = document.getElementById('prevBtn');
 window.nextBtn = document.getElementById('nextBtn');
 window.shuffleBtn = document.getElementById('shuffleBtn');
 window.repeatBtn = document.getElementById('repeatBtn');
 window.progressBar = document.getElementById('progressBar');
 window.progressFill = document.getElementById('progressFill');
 window.currentTimeEl = document.getElementById('currentTime');
 window.totalTimeEl = document.getElementById('totalTime');
 window.songTitle = document.getElementById('songTitle');
 window.artistName = document.getElementById('artistName');
 window.playlistContainer = document.getElementById('playlist');
 window.playlistCount = document.getElementById('playlistCount');
 window.volumeBtn = document.getElementById('volumeBtn');
 window.volumeIcon = document.getElementById('volumeIcon');
 window.muteIcon = document.getElementById('muteIcon');
 window.volumeSlider = document.getElementById('volumeSlider');
 window.volumeFill = document.getElementById('volumeFill');

 // Mood section and effects
 window.moodSection = document.querySelector('.mood-section');
 window.moodEffectsBtn = document.getElementById('moodEffectsBtn');
 window.moodEffectsPopup = document.getElementById('moodEffectsPopup');
 window.playlistTabsContainer = document.getElementById('playlistTabs');
 window.addPlaylistBtn = document.getElementById('addPlaylistBtn');
 
 // Settings elements
 window.settingsBtn = document.getElementById('settingsBtn');
 window.settingsModalOverlay = document.getElementById('settingsModalOverlay');
 window.closeSettingsModal = document.getElementById('closeSettingsModal');
 window.toggleStickyControls = document.getElementById('toggleStickyControls');
 window.toggleVisualizer = document.getElementById('toggleVisualizer');
 window.toggleBackgroundAnim = document.getElementById('toggleBackgroundAnim');
 window.toggleFloatingPlayerSetting = document.getElementById('toggleFloatingPlayer');
 
 // Floating Player elements
 window.floatingPlayer = document.getElementById('floatingPlayer');
 window.floatingPlayerBtn = document.getElementById('floatingPlayerBtn');
 window.closeFloatingPlayer = document.getElementById('closeFloatingPlayer');
 window.popoutWindowBtn = document.getElementById('popoutWindowBtn');
 window.floatingSongTitle = document.getElementById('floatingSongTitle');
window.addSongModalOverlay = document.getElementById('addSongModalOverlay');
window.closeAddSongModal = document.getElementById('closeAddSongModal');
window.cancelAddSong = document.getElementById('cancelAddSong');
window.addSongBtn = document.getElementById('addSongBtn');
window.addSongVideoUrl = document.getElementById('addSongVideoUrl');
window.addSongStatus = document.getElementById('addSongStatus');
window.addSongBtnText = document.getElementById('addSongBtnText');
window.addSongModalTitle = document.getElementById('addSongModalTitle');

window.targetPlaylistIndex = null;

 window.floatingArtistName = document.getElementById('floatingArtistName');
 window.floatingPlayPauseBtn = document.getElementById('floatingPlayPauseBtn');
 window.floatingPrevBtn = document.getElementById('floatingPrevBtn');
 window.floatingNextBtn = document.getElementById('floatingNextBtn');
 
 // Sticky Controls elements
 window.stickyControls = document.getElementById('stickyControls');
 window.stickySongTitle = document.getElementById('stickySongTitle');
 window.stickyArtistName = document.getElementById('stickyArtistName');
 window.stickyThumb = document.getElementById('stickyThumb');
 window.stickyPlayPauseBtn = document.getElementById('stickyPlayPauseBtn');
 window.stickyPrevBtn = document.getElementById('stickyPrevBtn');
 window.stickyNextBtn = document.getElementById('stickyNextBtn');
 window.musicVisualizer = document.getElementById('musicVisualizer');
 
 // Carousel elements
 window.carouselSection = document.getElementById('carouselSection');
 window.carouselTrack = document.getElementById('carouselTrack');
 window.carouselPrev = document.getElementById('carouselPrev');
 window.carouselNext = document.getElementById('carouselNext');
 
 // Library elements
 window.libraryBtn = document.getElementById('libraryBtn');
 window.libraryBadge = document.getElementById('libraryBadge');
 window.libraryModalOverlay = document.getElementById('libraryModalOverlay');
 window.libraryModalBody = document.getElementById('libraryModalBody');
 window.closeLibraryModal = document.getElementById('closeLibraryModal');
 
 // Import modal elements
 window.importPlaylistBtn = document.getElementById('importPlaylistBtn');
 window.playlistModalOverlay = document.getElementById('playlistModalOverlay');
 window.closePlaylistModal = document.getElementById('closePlaylistModal');
 window.cancelPlaylist = document.getElementById('cancelPlaylist');
 window.loadPlaylist = document.getElementById('loadPlaylist');
 window.playlistUrlInput = document.getElementById('playlistUrlInput');
 window.playlistNameInput = document.getElementById('playlistNameInput');
 window.playlistStatus = document.getElementById('playlistStatus');
 window.loadPlaylistText = document.getElementById('loadPlaylistText');
window.manualPlaylistCheckbox = document.getElementById('manualPlaylistCheckbox');
window.playlistUrlGroup = document.getElementById('playlistUrlGroup');
window.videoUrlGroup = document.getElementById('videoUrlGroup');
window.videoUrlInput = document.getElementById('videoUrlInput');
window.communityNotice = document.getElementById('communityNotice');
window.playlistModalTitle = document.getElementById('playlistModalTitle');


 // Mood Management
 window.moodOptions = document.querySelectorAll('.mood-option');
 window.currentMood = 'default';

window.loadMood = function() {
 const savedMood = localStorage.getItem('musicPlayerMood') || 'default';
 window.applyMood(savedMood);
 }

window.applyMood = function(mood) {
 window.currentMood = mood;
 document.body.className = mood !== 'default' ? `mood-${mood}` : '';

 window.moodOptions.forEach(option => {
 option.classList.toggle('active', option.dataset.mood === mood);
 });

 localStorage.setItem('musicPlayerMood', mood);

 // Update sticky color if Easter egg feature is enabled
 if (typeof updateStickyColor === 'function') {
 updateStickyColor(mood);
 }
 }

 window.moodOptions.forEach(option => {
 option.addEventListener('click', () => {
 window.applyMood(option.dataset.mood);
 });
 });

 // Mood Navigation Buttons
 const moodSelector = document.getElementById('moodSelector');
 const moodNavLeft = document.getElementById('moodNavLeft');
 const moodNavRight = document.getElementById('moodNavRight');

 if (moodNavLeft && moodNavRight && moodSelector) {
 moodNavLeft.addEventListener('click', () => {
 const scrollAmount = 200; // Scroll 200px to the left
 moodSelector.scrollBy({
 left: -scrollAmount,
 behavior: 'smooth'
 });
 });

 moodNavRight.addEventListener('click', () => {
 const scrollAmount = 200; // Scroll 200px to the right
 moodSelector.scrollBy({
 left: scrollAmount,
 behavior: 'smooth'
 });
 });
 }

 // Random Effect Functions
 const allMoods = ['default', 'sunset', 'ocean', 'forest', 'midnight', 'aurora', 'candy', 'neon', 'tropical', 'cosmic', 'plasma', 'starfield', 'lava', 'electric', 'matrix', 'rainbow', 'vaporwave', 'fire', 'twilight', 'galaxy'];
 const allAtmosphereEffects = ['shake', 'sway', 'float', 'wobble', 'tilt3d', 'flicker', 'glitch', 'rgbsplit', 'wavemotion', 'ripple', 'prism', 'borderpulse', 'neonglow', 'rainbowborder', 'shadowdance', 'electricedges'];
 const colorPalette = ['#667eea', '#764ba2', '#f093fb', '#43e97b', '#fa709a', '#fee140', '#667eea', '#ff6b6b', '#ffa07a', '#2e3192', '#1bffff', '#38d172'];

window.applyRandomMood = function() {
 const randomMood = allMoods[Math.floor(Math.random() * allMoods.length)];
 window.applyMood(randomMood);

 // Randomize MOOD title opacity (30-100%)
 const moodTitle = document.querySelector('.mood-title');
 if (moodTitle) {
 const randomOpacity = (Math.floor(Math.random() * 71) + 30) / 100; // 30-100%
 moodTitle.style.opacity = randomOpacity;
 }

 const btn = document.getElementById('randomMoodBtn');
 btn.classList.add('pulsing');
 setTimeout(() => btn.classList.remove('pulsing'), 600);
}

window.applyRandomAtmosphere = function() {
 // CRITICAL FIX: Disable transitions during randomization to prevent flickering
 document.body.classList.add('no-transition');

 // Clear all effects first
 window.activeEffects = [];
 document.querySelectorAll('.effect-btn').forEach(btn => {
 btn.classList.remove('active');
 });

 // === WEIGHTED RANDOMIZATION SYSTEM ===
 // High-probability core effects (these appear most of the time)
 if (Math.random() < 0.90) { // 90% chance
   window.activeEffects.push('wavemotion');
 }
 if (Math.random() < 0.85) { // 85% chance
   window.activeEffects.push('prism');
 }
 if (Math.random() < 0.70) { // 70% chance
   window.activeEffects.push('rainbowborder');
 }

 // === AUDIO TEXTURES (Always applied) ===
 // Prioritize animated textures for better visual effect
 const animatedTextures = [
   'frequency-spectrum', 'oscilloscope', 'soundwave-circular', 'amplitude-pulse',
   'stereo-waves', 'frequency-rings', 'audio-spectrum-3d', 'sine-waves',
   'beat-grid', 'harmonic-waves',
   'pulse-wave', 'digital-eq', 'sound-particle', 'waveform-flow',
   'bass-pulse', 'audio-ripple', 'frequency-burst', 'sound-spiral',
   'beat-pulse', 'harmonic-flow'
 ];
 const randomTexture = animatedTextures[Math.floor(Math.random() * animatedTextures.length)];

 // Apply texture
 document.querySelectorAll('.texture-btn').forEach(btn => btn.classList.remove('active'));
 const textureBtn = document.querySelector(`.texture-btn[data-texture="${randomTexture}"]`);
 if (textureBtn) textureBtn.classList.add('active');

 // Trigger texture application
 const textureClickEvent = new Event('click');
 if (textureBtn) textureBtn.dispatchEvent(textureClickEvent);

 // === PULSE EFFECTS (1-2 random) ===
 const pulseEffects = ['heartbeat', 'flash', 'glowpulse', 'scalebounce', 'breathe', 'beatdrop'];
 const numPulse = Math.floor(Math.random() * 2) + 1; // 1 or 2
 for (let i = 0; i < numPulse; i++) {
   const effect = pulseEffects[Math.floor(Math.random() * pulseEffects.length)];
   if (!window.activeEffects.includes(effect)) {
     window.activeEffects.push(effect);
   }
 }

 // === BORDER EFFECTS (1 random, excluding rainbow if already added) ===
 const borderEffects = window.activeEffects.includes('rainbowborder')
   ? ['borderpulse', 'neonglow', 'shadowdance', 'electricedges']
   : ['borderpulse', 'neonglow', 'shadowdance', 'electricedges', 'rainbowborder'];

 const borderEffect = borderEffects[Math.floor(Math.random() * borderEffects.length)];
 if (!window.activeEffects.includes(borderEffect)) {
   window.activeEffects.push(borderEffect);
 }

 // === VISUAL FX (1-2 progressive effects) ===
 const visualFX = ['flicker', 'glitch', 'rgbsplit', 'ripple'];
 const numVisual = Math.floor(Math.random() * 2) + 1; // 1 or 2
 for (let i = 0; i < numVisual; i++) {
   const effect = visualFX[Math.floor(Math.random() * visualFX.length)];
   if (!window.activeEffects.includes(effect)) {
     window.activeEffects.push(effect);
   }
 }

 // Mark all active effects
 window.activeEffects.forEach(effect => {
   const btn = document.querySelector(`.effect-btn[data-effect="${effect}"]`);
   if (btn) btn.classList.add('active');
 });

 // Apply effects
 window.updateEffects();

 // === OPACITY RANDOMIZATION (60-95% for nice transparency) ===
 const randomOpacity = Math.floor(Math.random() * 36) + 60; // 60-95%
 const bgOpacity = document.getElementById('bgOpacity');
 const bgOpacityValue = document.getElementById('bgOpacityValue');
 if (bgOpacity && bgOpacityValue) {
   bgOpacity.value = randomOpacity;
   bgOpacityValue.textContent = randomOpacity + '%';

   // Apply opacity to mood section
   const r = parseInt(bgColor.value.slice(1, 3), 16);
   const g = parseInt(bgColor.value.slice(3, 5), 16);
   const b = parseInt(bgColor.value.slice(5, 7), 16);
   window.moodSection.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${randomOpacity / 100})`;
 }

 // Randomize MOOD title opacity (30-100%)
 const moodTitle = document.querySelector('.mood-title');
 if (moodTitle) {
 const titleOpacity = (Math.floor(Math.random() * 71) + 30) / 100; // 30-100%
 moodTitle.style.opacity = titleOpacity;
 }

 // Re-enable transitions after effects are applied
 requestAnimationFrame(() => {
 requestAnimationFrame(() => {
 document.body.classList.remove('no-transition');
 });
 });

 const btn = document.getElementById('randomAtmosphereBtn');
 btn.classList.add('pulsing');
 setTimeout(() => btn.classList.remove('pulsing'), 600);
}

window.applyRandomBgEffects = function() {
 // Choose random mode for variety
 const modes = ['minimal', 'moderate', 'dramatic', 'neon', 'retro'];
 const mode = modes[Math.floor(Math.random() * modes.length)];

 // Random background color
 const randomColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
 bgColor.value = randomColor;

 // Random opacity (60-100%) - NOW INCLUDED!
 const randomOpacity = Math.floor(Math.random() * 41) + 60;
 bgOpacity.value = randomOpacity;
 bgOpacityValue.textContent = randomOpacity + '%';

 // Random blur based on mode
 let randomBlur = 0;
 if (mode === 'dramatic' || mode === 'neon') {
 randomBlur = Math.floor(Math.random() * 16) + 5; // 5-20px
 } else if (mode === 'moderate') {
 randomBlur = Math.floor(Math.random() * 11); // 0-10px
 } // minimal and retro: no blur

 bgBlur.value = randomBlur;
 bgBlurValue.textContent = randomBlur + 'px';

 // Random border radius (8-30px) - LIMITED!
 const randomRadius = Math.floor(Math.random() * 23) + 8;
 borderRadius.value = randomRadius;
 borderRadiusValue.textContent = randomRadius + 'px';

 // Random shadow depth based on mode
 let randomShadow = 0;
 if (mode === 'dramatic' || mode === 'neon') {
 randomShadow = Math.floor(Math.random() * 21) + 10; // 10-30px
 } else if (mode === 'moderate') {
 randomShadow = Math.floor(Math.random() * 16); // 0-15px
 } else if (mode === 'retro') {
 randomShadow = Math.floor(Math.random() * 6); // 0-5px
 }

 bgShadowDepth.value = randomShadow;
 bgShadowDepthValue.textContent = randomShadow + 'px';

 // Random border glow (3-8px) - EVEN SMALLER!
 let randomGlow = 0;
 if (mode === 'neon') {
 randomGlow = Math.floor(Math.random() * 6) + 3; // 3-8px
 } else if (mode === 'dramatic') {
 randomGlow = Math.floor(Math.random() * 4) + 3; // 3-6px
 } else if (mode === 'moderate') {
 randomGlow = Math.floor(Math.random() * 3) + 3; // 3-5px
 }

 const randomGlowColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
 bgBorderGlow.value = randomGlow;
 bgBorderGlowValue.textContent = randomGlow + 'px';
 bgBorderGlowColor.value = randomGlowColor;

 // Random border animation
 const borderAnimations = ['border-flash', 'border-flicker', 'border-breathing', 'border-colorshift'];
 const randomAnimation = borderAnimations[Math.floor(Math.random() * borderAnimations.length)];

 // Random CSS border (width and style) - NEW!
 let borderStyle = 'none';
 let borderWidth = 0;
 let borderColor = randomGlowColor;

 if (mode === 'retro') {
 borderStyle = ['solid', 'dashed', 'dotted', 'double'][Math.floor(Math.random() * 4)];
 borderWidth = Math.floor(Math.random() * 3) + 2; // 2-4px
 } else if (mode === 'dramatic') {
 borderStyle = 'solid';
 borderWidth = Math.floor(Math.random() * 2) + 1; // 1-2px
 }

 // Random filters - NEW!
 const saturation = Math.floor(Math.random() * 41) + 80; // 80-120%
 const brightness = Math.floor(Math.random() * 21) + 90; // 90-110%
 const contrast = Math.floor(Math.random() * 21) + 90; // 90-110%

 // Apply all effects to mood section
 window.moodSection.style.backgroundColor = randomColor;
 window.moodSection.style.opacity = (randomOpacity / 100);
 window.moodSection.style.backdropFilter = randomBlur > 0 ? `blur(${randomBlur}px)` : '';
 window.moodSection.style.borderRadius = randomRadius + 'px';
 window.moodSection.style.border = borderWidth > 0 ? `${borderWidth}px ${borderStyle} ${borderColor}` : '';

 // Box shadow
 let boxShadow = randomShadow > 0 ? `0 ${randomShadow}px ${randomShadow * 2}px rgba(0,0,0,0.3)` : '';
 if (randomGlow > 0) {
 const glowShadow = `0 0 ${randomGlow}px ${randomGlow * 2}px ${randomGlowColor}`;
 boxShadow = boxShadow ? boxShadow + ', ' + glowShadow : glowShadow;
 }
 window.moodSection.style.boxShadow = boxShadow;

 // Filters only (transform removed to prevent mobile sticky control issues)
 window.moodSection.style.filter = `saturate(${saturation}%) brightness(${brightness}%) contrast(${contrast}%)`;
 window.moodSection.style.transform = ''; // Clear any previous transforms

 // Border animations
 window.moodSection.classList.remove('border-flash', 'border-flicker', 'border-breathing', 'border-colorshift');
 if (randomGlow > 0) {
 window.moodSection.classList.add(randomAnimation);
 }

 // Apply to video player
 const videoPlayerContainer = document.querySelector('.video-player-container');
 if (videoPlayerContainer) {
 let videoBoxShadow = '0 10px 30px rgba(0, 0, 0, 0.2)';
 if (randomGlow > 0) {
 videoBoxShadow += `, 0 0 ${randomGlow}px ${randomGlow * 2}px ${randomGlowColor}`;
 }
 videoPlayerContainer.style.boxShadow = videoBoxShadow;
 videoPlayerContainer.style.border = borderWidth > 0 ? `${borderWidth}px ${borderStyle} ${borderColor}` : '';
 videoPlayerContainer.classList.remove('border-flash', 'border-flicker', 'border-breathing', 'border-colorshift');
 if (randomGlow > 0) {
 videoPlayerContainer.classList.add(randomAnimation);
 }
 }

 // Random texture - EXPANDED with 10 new music wave textures!
 const textures = ['none', 'speaker-grille', 'sound-waves', 'equalizer', 'waveform', 'bass-ripples', 'studio-foam', 'audio-jack', 'mic-mesh', 'piano-keys', 'guitar-strings', 'drum-skin', 'foam-pyramids', 'xlr-connector', 'cassette-tape', 'cd-diffraction', 'mixing-console', 'frequency-spectrum', 'oscilloscope', 'soundwave-circular', 'amplitude-pulse', 'stereo-waves', 'frequency-rings', 'audio-spectrum-3d', 'sine-waves', 'beat-grid', 'harmonic-waves'];
 let randomTexture;

 // Mode-specific texture preferences
 if (mode === 'neon') {
 // Neon mode prefers modern tech textures
 randomTexture = ['equalizer', 'sound-waves', 'cd-diffraction', 'mixing-console'][Math.floor(Math.random() * 4)];
 } else if (mode === 'retro') {
 // Retro mode prefers vintage textures
 randomTexture = ['cassette-tape', 'piano-keys', 'guitar-strings', 'speaker-grille', 'studio-foam'][Math.floor(Math.random() * 5)];
 } else if (mode === 'dramatic') {
 // Dramatic mode can use any texture or none
 randomTexture = textures[Math.floor(Math.random() * textures.length)];
 } else {
 // Minimal and moderate modes: 50% chance of no texture
 randomTexture = Math.random() < 0.5 ? 'none' : textures[Math.floor(Math.random() * textures.length)];
 }

 // Apply texture
 currentTexture = randomTexture;
 document.querySelectorAll('.texture-btn').forEach(btn => btn.classList.remove('active'));
 const textureBtn = document.querySelector(`.texture-btn[data-texture="${randomTexture}"]`);
 if (textureBtn) textureBtn.classList.add('active');
 applyTexture(randomTexture);

 // Randomize MOOD title opacity (30-100%)
 const moodTitle = document.querySelector('.mood-title');
 if (moodTitle) {
 const randomOpacity = (Math.floor(Math.random() * 71) + 30) / 100; // 30-100%
 moodTitle.style.opacity = randomOpacity;
 }

 const btn = document.getElementById('randomBgBtn');
 btn.classList.add('pulsing');
 setTimeout(() => btn.classList.remove('pulsing'), 600);
}

 // Settings Management
window.loadSettings = function() {
 const saved = localStorage.getItem('musicPlayerSettings');
 if (saved) {
 settings = JSON.parse(saved);
 }
 applySettings();
 }

window.saveSettings = function() {
 localStorage.setItem('musicPlayerSettings', JSON.stringify(settings));
 }

window.applySettings = function() {
 toggleStickyControls.checked = settings.stickyControls;
 toggleVisualizer.checked = settings.visualizer;
 toggleBackgroundAnim.checked = settings.backgroundAnim;
 toggleFloatingPlayerSetting.checked = settings.floatingPlayer;
 
 if (!settings.stickyControls) {
 stickyControls.classList.add('hidden');
 } else {
 stickyControls.classList.remove('hidden');
 }
 
 if (!settings.visualizer) {
 musicVisualizer.style.display = 'none';
 } else {
 musicVisualizer.style.display = 'flex';
 }
 
 if (!settings.backgroundAnim) {
 document.querySelector('.bg-animation').style.display = 'none';
 } else {
 document.querySelector('.bg-animation').style.display = 'block';
 }
 
 if (settings.floatingPlayer && !floatingPlayerActive) {
 toggleFloatingPlayer();
 }
 }

 // Settings Event Listeners
 settingsBtn.addEventListener('click', () => {
 settingsModalOverlay.classList.add('active');
 });

 closeSettingsModal.addEventListener('click', () => {
 settingsModalOverlay.classList.remove('active');
 });

 settingsModalOverlay.addEventListener('click', (e) => {
 if (e.target === settingsModalOverlay) {
 settingsModalOverlay.classList.remove('active');
 }
 });

 toggleStickyControls.addEventListener('change', (e) => {
 settings.stickyControls = e.target.checked;
 if (!settings.stickyControls) {
 stickyControls.classList.add('hidden');
 } else {
 stickyControls.classList.remove('hidden');
 }
 saveSettings();
 });

 toggleVisualizer.addEventListener('change', (e) => {
 settings.visualizer = e.target.checked;
 if (!settings.visualizer) {
 musicVisualizer.style.display = 'none';
 } else {
 musicVisualizer.style.display = 'flex';
 }
 saveSettings();
 });

 toggleBackgroundAnim.addEventListener('change', (e) => {
 settings.backgroundAnim = e.target.checked;
 if (!settings.backgroundAnim) {
 document.querySelector('.bg-animation').style.display = 'none';
 } else {
 document.querySelector('.bg-animation').style.display = 'block';
 }
 saveSettings();
 });

 toggleFloatingPlayerSetting.addEventListener('change', (e) => {
 settings.floatingPlayer = e.target.checked;
 if (settings.floatingPlayer && !floatingPlayerActive) {
 toggleFloatingPlayer();
 } else if (!settings.floatingPlayer && floatingPlayerActive) {
 toggleFloatingPlayer();
 }
 saveSettings();
 });

 // Background Animation - Particles
window.createParticles = function() {
 const particlesContainer = document.getElementById('particles');
 const particleCount = 20;
 
 for (let i = 0; i < particleCount; i++) {
 const particle = document.createElement('div');
 particle.className = 'particle';
 particle.style.left = Math.random() * 100 + '%';
 particle.style.animationDelay = Math.random() * 10 + 's';
 particle.style.animationDuration = (8 + Math.random() * 4) + 's';
 particlesContainer.appendChild(particle);
 }
 }

 // Floating Player Functions
window.toggleFloatingPlayer = function() {
 floatingPlayerActive = !floatingPlayerActive;
 
 if (floatingPlayerActive) {
 floatingPlayer.classList.add('active');
 floatingPlayerBtn.classList.add('active');
 floatingPlayerBtn.innerHTML = '<span>üì∫</span><span>Hide Floating Video</span>';
 updateFloatingPlayerInfo();
 } else {
 floatingPlayer.classList.remove('active');
 floatingPlayerBtn.classList.remove('active');
 floatingPlayerBtn.innerHTML = '<span>üì∫</span><span>Floating Video Player</span>';
 }
 }

window.updateFloatingPlayerInfo = function() {
 const songs = window.getCurrentSongs();
 if (songs.length === 0 || window.currentSongIndex >= songs.length) return;
 
 const song = songs[window.currentSongIndex];
 window.floatingSongTitle.textContent = song.title || 'No Track';
 window.floatingArtistName.textContent = song.artist || 'Unknown Artist';
 }

 // Pop-out Window Function
window.openPopoutWindow = function() {
 const songs = window.getCurrentSongs();
 if (songs.length === 0 || window.currentSongIndex >= songs.length) return;
 
 const song = songs[window.currentSongIndex];
 const videoId = song.videoId;
 
 if (window.popoutWindow && !window.popoutWindow.closed) {
 window.popoutWindow.focus();
 return;
 }
 
 const windowFeatures = 'width=500,height=400,menubar=no,toolbar=no,location=no,status=no';
 window.popoutWindow = window.open('', 'MusicPlayerPopout', windowFeatures);
 
 window.popoutWindow.document.write(`
 <!DOCTYPE html>
 <html>
 <head>
 <title>${song.title} - Music Player</title>
 <style>
 body { margin: 0; padding: 0; background: #000; overflow: hidden; }
 #popout-player { width: 100%; height: 100%; }
 </style>
 </head>
 <body>
 <div id="popout-player"></div>
 <script src="https://www.youtube.com/iframe_api"><\/script>
 <script>
 let popoutYTPlayer;
window.onYouTubeIframeAPIReady = function() {
 popoutYTPlayer = new YT.Player('popout-player', {
 height: '100%',
 width: '100%',
 videoId: '${videoId}',
 playerVars: {
 'autoplay': ${isPlaying ? 1 : 0},
 'controls': 1,
 'rel': 0,
 'showinfo': 1,
 'modestbranding': 1
 }
 });
 }
 <\/script>
 </body>
 </html>
 `);
 window.popoutWindow.document.close();
 }

 // Update Sticky Controls Info
window.updateStickyControlsInfo = function() {
 const songs = window.getCurrentSongs();
 if (songs.length === 0 || window.currentSongIndex >= songs.length) return;
 
 const song = songs[window.currentSongIndex];
 stickySongTitle.textContent = song.title || 'No Track';
 stickyArtistName.textContent = song.artist || 'Unknown Artist';
 
 if (song.thumbnail) {
 stickyThumb.innerHTML = `<img src="${song.thumbnail}" alt="${song.title}">`;
 } else {
 stickyThumb.innerHTML = `<div class="playlist-thumb-placeholder">${(song.artist || 'U').charAt(0)}</div>`;
 }
 }

 // Update Visualizer State
window.updateVisualizerState = function() {
 if (isPlaying) {
 musicVisualizer.classList.remove('paused');
 musicVisualizer.classList.add('playing');
 } else {
 musicVisualizer.classList.remove('playing');
 musicVisualizer.classList.add('paused');
 }
 }

 // Media Session API for Native Mobile Controls
window.setupMediaSession = function() {
 if ('mediaSession' in navigator) {
 const songs = window.getCurrentSongs();
 if (songs.length === 0 || window.currentSongIndex >= songs.length) return;
 
 const song = songs[window.currentSongIndex];
 
 navigator.mediaSession.metadata = new MediaMetadata({
 title: song.title || 'Unknown Title',
 artist: song.artist || 'Unknown Artist',
 artwork: song.thumbnail ? [
 { src: song.thumbnail, sizes: '96x96', type: 'image/jpeg' },
 { src: song.thumbnail, sizes: '128x128', type: 'image/jpeg' },
 { src: song.thumbnail, sizes: '192x192', type: 'image/jpeg' },
 { src: song.thumbnail, sizes: '256x256', type: 'image/jpeg' },
 { src: song.thumbnail, sizes: '384x384', type: 'image/jpeg' },
 { src: song.thumbnail, sizes: '512x512', type: 'image/jpeg' }
 ] : []
 });

 navigator.mediaSession.setActionHandler('play', () => {
 play();
 });

 navigator.mediaSession.setActionHandler('pause', () => {
 pause();
 });

 navigator.mediaSession.setActionHandler('previoustrack', () => {
 window.prevSong();
 });

 navigator.mediaSession.setActionHandler('nexttrack', () => {
 window.nextSong();
 });

 navigator.mediaSession.setActionHandler('seekbackward', (details) => {
 if (window.player && window.player.getCurrentTime && window.player.seekTo) {
 const currentTime = window.player.getCurrentTime();
 window.player.seekTo(Math.max(0, currentTime - (details.seekOffset || 10)));
 }
 });

 navigator.mediaSession.setActionHandler('seekforward', (details) => {
 if (window.player && window.player.getCurrentTime && player.getDuration && window.player.seekTo) {
 const currentTime = window.player.getCurrentTime();
 const duration = window.player.getDuration();
 window.player.seekTo(Math.min(duration, currentTime + (details.seekOffset || 10)));
 }
 });
 }
 }

 // Dragging functionality for floating player
window.setupDragging = function() {
 floatingPlayer.addEventListener('mousedown', startDragging);
 document.addEventListener('mousemove', drag);
 document.addEventListener('mouseup', stopDragging);
 
 floatingPlayer.addEventListener('touchstart', startDragging);
 document.addEventListener('touchmove', drag);
 document.addEventListener('touchend', stopDragging);
 }

window.startDragging = function(e) {
 if (e.target.closest('.floating-action-btn') || 
 e.target.closest('.floating-control-btn')) {
 return;
 }
 
 isDragging = true;
 const touch = e.touches ? e.touches[0] : e;
 const rect = floatingPlayer.getBoundingClientRect();
 
 dragOffsetX = touch.clientX - rect.left;
 dragOffsetY = touch.clientY - rect.top;
 
 floatingPlayer.style.cursor = 'grabbing';
 }

window.drag = function(e) {
 if (!isDragging) return;
 
 e.preventDefault();
 const touch = e.touches ? e.touches[0] : e;
 
 let newX = touch.clientX - dragOffsetX;
 let newY = touch.clientY - dragOffsetY;
 
 // Keep within viewport bounds
 newX = Math.max(0, Math.min(newX, window.innerWidth - floatingPlayer.offsetWidth));
 newY = Math.max(0, Math.min(newY, window.innerHeight - floatingPlayer.offsetHeight));
 
 floatingPlayer.style.right = 'auto';
 floatingPlayer.style.bottom = 'auto';
 floatingPlayer.style.left = newX + 'px';
 floatingPlayer.style.top = newY + 'px';
 }

window.stopDragging = function() {
 isDragging = false;
 floatingPlayer.style.cursor = 'move';
 }

 // YouTube Player callback functions are now defined at the TOP of this file
 // This prevents race conditions during initialization

window.updateAllPlayButtons = function(state) {
 var playIconHTML = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
 var pauseIconHTML = '<svg viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>';
 
 if (state === 'pause') {
 window.floatingPlayPauseBtn.innerHTML = pauseIconHTML;
 window.stickyPlayPauseBtn.innerHTML = pauseIconHTML;
 } else {
 window.floatingPlayPauseBtn.innerHTML = playIconHTML;
 window.stickyPlayPauseBtn.innerHTML = playIconHTML;
 }
 }

window.startProgressUpdater = function() {
 window.stopProgressUpdater();
 window.progressInterval = setInterval(() => {
 if (window.player && window.player.getCurrentTime) {
 const currentTime = window.player.getCurrentTime();
 const duration = window.player.getDuration();
 window.updateProgressDisplay(currentTime, duration);
 }
 }, 100);
 }

window.stopProgressUpdater = function() {
 if (window.progressInterval) {
 clearInterval(window.progressInterval);
 window.progressInterval = null;
 }
 }

window.updateProgressDisplay = function(currentTime, duration) {
 if (duration > 0) {
 const percentage = (currentTime / duration) * 100;
 progressFill.style.width = percentage + '%';
 currentTimeEl.textContent = formatTime(currentTime);
 totalTimeEl.textContent = formatTime(duration);
 }
 }

 // Helper Functions
window.getRandomColor = function() {
 const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#fee140', '#30cfd0', '#a8edea', '#fed6e3'];
 return colors[Math.floor(Math.random() * colors.length)];
 }

window.extractPlaylistId = function(url) {
 const patterns = [
 /[?&]list=([^&]+)/,
 /^([A-Za-z0-9_-]+)$/
 ];
 
 for (const pattern of patterns) {
 const match = url.match(pattern);
 if (match) return match[1];
 }
 
 return null;
 }

 // Extract Video ID from YouTube URL
window.extractVideoId = function(url) {
 const patterns = [
 /(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\?\/]+)/,
 /^([A-Za-z0-9_-]{11})$/
 ];
 
 for (const pattern of patterns) {
 const match = url.match(pattern);
 if (match) return match[1];
 }
 
 return null;
 }

 // Fetch Single Video Info from YouTube
 window.fetchVideoInfo = async function(videoId) {
 try {
 const url = `${YOUTUBE_API_BASE}/videos?part=snippet,contentDetails&id=${videoId}&key=${YOUTUBE_API_KEY}`;
 const response = await fetch(url);
 const data = await response.json();
 
 if (!data.items || data.items.length === 0) {
 throw new Error('Video not found');
 }
 
 const video = data.items[0];
 const snippet = video.snippet;
 const duration = video.contentDetails.duration;
 
 return {
 title: snippet.title,
 artist: snippet.channelTitle || 'Unknown Artist',
 duration: window.parseYouTubeDuration(duration),
 albumColor: window.getRandomColor(),
 source: `https://www.youtube.com/watch?v=${videoId}`,
 sourceType: 'youtube',
 thumbnail: snippet.thumbnails?.maxres?.url || snippet.thumbnails?.high?.url || snippet.thumbnails?.medium?.url || snippet.thumbnails?.default?.url || null,
 videoId: videoId,
 addedManually: true
 };
 } catch (error) {
 console.error('Error fetching video info:', error);
 throw error;
 }
 }

window.parseYouTubeDuration = function(duration) {
 const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
 if (!match) return '0:00';
 
 const hours = parseInt(match[1] || 0);
 const minutes = parseInt(match[2] || 0);
 const seconds = parseInt(match[3] || 0);
 
 if (hours > 0) {
 return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
 }
 return `${minutes}:${seconds.toString().padStart(2, '0')}`;
 }

window.formatTime = function(seconds) {
 const min = Math.floor(seconds / 60);
 const sec = Math.floor(seconds % 60);
 return `${min}:${sec.toString().padStart(2, '0')}`;
 }

 // YouTube API Functions
 window.fetchYouTubePlaylist = async function(playlistId) {
 try {
 let allItems = [];
 let nextPageToken = '';
 
 playlistStatus.textContent = 'Fetching playlist...';
 
 do {
 const url = `${YOUTUBE_API_BASE}/playlistItems?part=snippet,contentDetails&maxResults=50&playlistId=${playlistId}&key=${YOUTUBE_API_KEY}${nextPageToken ? '&pageToken=' + nextPageToken : ''}`;
 
 const response = await fetch(url);
 const data = await response.json();
 
 if (data.error) {
 throw new Error(data.error.message || 'Failed to fetch playlist');
 }
 
 allItems = allItems.concat(data.items || []);
 nextPageToken = data.nextPageToken || '';
 
 playlistStatus.textContent = `Fetching... (${allItems.length} videos)`;
 
 } while (nextPageToken);
 
 playlistStatus.textContent = `Fetching video details...`;
 
 const videoIds = allItems.map(item => item.contentDetails.videoId).filter(id => id);
 
 if (videoIds.length === 0) {
 throw new Error('No videos found in playlist');
 }
 
 const videoDetails = [];
 for (let i = 0; i < videoIds.length; i += 50) {
 const batch = videoIds.slice(i, i + 50);
 const detailsUrl = `${YOUTUBE_API_BASE}/videos?part=contentDetails&id=${batch.join(',')}&key=${YOUTUBE_API_KEY}`;
 
 const response = await fetch(detailsUrl);
 const data = await response.json();
 
 if (data.items) {
 videoDetails.push(...data.items);
 }
 
 playlistStatus.textContent = `Processing... (${Math.min(i + 50, videoIds.length)}/${videoIds.length})`;
 }
 
 const durationMap = {};
 videoDetails.forEach(video => {
 durationMap[video.id] = video.contentDetails.duration;
 });
 
 const newSongs = allItems.map(item => {
 const snippet = item.snippet;
 const videoId = item.contentDetails.videoId;
 const duration = durationMap[videoId] || 'PT0S';
 
 return {
 title: snippet.title,
 artist: snippet.videoOwnerChannelTitle || snippet.channelTitle || 'Unknown Artist',
 duration: window.parseYouTubeDuration(duration),
 albumColor: window.getRandomColor(),
 source: `https://www.youtube.com/watch?v=${videoId}`,
 sourceType: 'youtube',
 thumbnail: snippet.thumbnails?.maxres?.url || snippet.thumbnails?.high?.url || snippet.thumbnails?.medium?.url || snippet.thumbnails?.default?.url || null,
 videoId: videoId
 };
 }).filter(song => song.title && song.title !== 'Private video' && song.title !== 'Deleted video');
 
 return newSongs;
 
 } catch (error) {
 console.error('YouTube API Error:', error);
 throw error;
 }
 }

 window.importYouTubePlaylist = async function(playlistIdOrUrl, playlistName) {
 const playlistId = window.extractPlaylistId(playlistIdOrUrl);

 if (!playlistId) {
 alert('Invalid playlist URL or ID. Please check and try again.');
 return;
 }
 
 try {
 loadPlaylist.disabled = true;
 loadPlaylistText.innerHTML = '<span class="loading-spinner"></span> Loading...';
 
 const newSongs = await window.fetchYouTubePlaylist(playlistId);
 
 if (newSongs.length === 0) {
 throw new Error('No valid videos found in playlist');
 }
 
 const newPlaylist = {
 id: Date.now(),
 name: playlistName || `Playlist ${window.playlists.length + 1}`,
 songs: newSongs,
 youtubePlaylistId: playlistId
 };

 window.playlists.push(newPlaylist);
 window.currentPlaylistIndex = window.playlists.length - 1;

 // Save to community library
 await window.saveToLibrary(newPlaylist);

 window.savePlaylists();
 window.initPlaylistTabs();
 window.initPlaylist();
 window.initCarousel();

 if (newSongs.length > 0 && window.playerReady) {
 window.selectSong(0);
 }

 playlistStatus.style.color = '#34C759';
 playlistStatus.textContent = `‚úì Imported ${newSongs.length} songs & shared with community!`;

 setTimeout(() => {
 window.closePlaylistModalFunc();
 }, 2000);
 
 } catch (error) {
 console.error('Import error:', error);
 playlistStatus.style.color = '#FF3B30';
 playlistStatus.textContent = `‚úó Error: ${error.message}`;
 
 loadPlaylist.disabled = false;
 loadPlaylistText.textContent = 'Import & Share';
 }
 }

 // Create Manual Playlist with Single Video
 window.createManualPlaylist = async function(videoUrl, playlistName) {
 const videoId = window.extractVideoId(videoUrl);

 if (!videoId) {
 alert('Invalid video URL. Please check and try again.');
 return;
 }
 
 try {
 loadPlaylist.disabled = true;
 loadPlaylistText.innerHTML = '<span class="loading-spinner"></span> Loading...';
 
 const videoInfo = await window.fetchVideoInfo(videoId);
 
 const newPlaylist = {
 id: Date.now(),
 name: playlistName || 'Manual Playlist ' + (window.playlists.length + 1),
 songs: [videoInfo],
 isManual: true,
 youtubePlaylistId: null
 };

 window.playlists.push(newPlaylist);
 window.currentPlaylistIndex = window.playlists.length - 1;

 window.savePlaylists();
 window.initPlaylistTabs();
 window.initPlaylist();
 window.initCarousel();

 if (window.playlists[window.currentPlaylistIndex].songs.length > 0 && window.playerReady) {
 window.selectSong(0);
 }

 playlistStatus.style.color = '#34C759';
 playlistStatus.textContent = '‚úì Manual playlist created with 1 song!';

 setTimeout(() => {
 window.closePlaylistModalFunc();
 }, 2000);
 
 } catch (error) {
 console.error('Error creating manual playlist:', error);
 playlistStatus.style.color = '#FF3B30';
 playlistStatus.textContent = '‚úó Error: ' + error.message;
 
 loadPlaylist.disabled = false;
 loadPlaylistText.textContent = 'Create Playlist';
 }
 }

 // Firebase Library Functions
 window.saveToLibrary = async function(playlist) {
 const libraryEntry = {
 id: playlist.id,
 name: playlist.name,
 youtubePlaylistId: playlist.youtubePlaylistId,
 songs: playlist.songs,
 dateAdded: new Date().toISOString(),
 trackCount: playlist.songs.length,
 thumbnail: playlist.songs[0]?.thumbnail || null
 };
 
 if (window.firebaseAvailable) {
 try {
 const snapshot = await window.database.ref('playlists').orderByChild('youtubePlaylistId').equalTo(playlist.youtubePlaylistId).once('value');
 
 if (!snapshot.exists()) {
 await window.database.ref('playlists').push(libraryEntry);
 console.log('‚úì Playlist saved to Firebase community library!');
 await window.loadLibrary();
 } else {
 console.log('‚ÑπÔ∏è Playlist already in community library');
 }
 } catch (e) {
 console.error('Firebase save error:', e);
 window.saveToLocalStorage(libraryEntry);
 }
 } else {
 window.saveToLocalStorage(libraryEntry);
 }
 }

window.saveToLocalStorage = function(libraryEntry) {
 const exists = playlistLibrary.find(p => p.youtubePlaylistId === libraryEntry.youtubePlaylistId);
 if (!exists) {
 playlistLibrary.unshift(libraryEntry);
 localStorage.setItem('playlistLibrary', JSON.stringify(playlistLibrary));
 window.updateLibraryBadge();
 }
 }

 window.loadLibrary = async function() {
 if (window.firebaseAvailable) {
 try {
 const snapshot = await window.database.ref('playlists').orderByChild('dateAdded').once('value');
 playlistLibrary = [];
 
 snapshot.forEach(childSnapshot => {
 playlistLibrary.push(childSnapshot.val());
 });
 
 playlistLibrary.reverse();
 console.log(`‚úì Loaded ${playlistLibrary.length} playlists from Firebase`);
 window.updateLibraryBadge();
 } catch (e) {
 console.error('Firebase load error:', e);
 window.loadFromLocalStorage();
 }
 } else {
 window.loadFromLocalStorage();
 }
 }

window.loadFromLocalStorage = function() {
 try {
 const saved = localStorage.getItem('playlistLibrary');
 if (saved) {
 playlistLibrary = JSON.parse(saved);
 console.log(`‚úì Loaded ${playlistLibrary.length} playlists from localStorage`);
 }
 window.updateLibraryBadge();
 } catch (e) {
 console.error('Error loading library:', e);
 window.updateLibraryBadge();
 }
 }

window.updateLibraryBadge = function() {
 const count = playlistLibrary.length;
 libraryBadge.textContent = count > 0 ? `(${count} available)` : '(Empty)';
 }

 // Library Pagination State
 let libraryCurrentPage = 1;
 const libraryPageSize = 20;
 let libraryTotalPages = 1;
 let librarySearchQuery = '';
 let librarySearchTimeout = null;
 let libraryPageCache = {};

 // Library Elements
 const librarySearchInput = document.getElementById('librarySearchInput');
 const librarySearchBtn = document.getElementById('librarySearchBtn');
 const librarySearchPreview = document.getElementById('librarySearchPreview');
 const libraryPaginationTop = document.getElementById('libraryPaginationTop');
 const libraryPaginationBottom = document.getElementById('libraryPaginationBottom');

window.openLibraryModal = function() {
 libraryModalOverlay.classList.add('active');
 libraryCurrentPage = 1;
 librarySearchQuery = '';
 librarySearchInput.value = '';
 libraryPageCache = {};
 loadLibraryPage(1);
 }

window.closeLibraryModalFunc = function() {
 libraryModalOverlay.classList.remove('active');
 librarySearchPreview.classList.remove('active');
 }

window.renderLibrary = function() {
 if (playlistLibrary.length === 0) {
 libraryModalBody.innerHTML = `
 <div class="library-empty">
 <div class="library-empty-icon">üìö</div>
 <div class="library-empty-text">
 No playlists in community library yet.<br>
 Import a YouTube playlist to get started!<br><br>
 ${window.firebaseAvailable ? '<strong style="color: #43e97b;">üåê Firebase Connected</strong> - Your imports are shared with everyone!' : '<strong style="color: #ff9500;">‚ö†Ô∏è Using Local Storage</strong> - Enable Firebase for cross-device sharing'}
 </div>
 </div>
 `;
 return;
 }
 
 const grid = document.createElement('div');
 grid.className = 'library-grid';
 
 playlistLibrary.forEach(playlist => {
 const card = document.createElement('div');
 card.className = 'library-card';
 
 const date = new Date(playlist.dateAdded);
 const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
 
 card.innerHTML = `
 <div class="library-card-image">
 ${playlist.thumbnail ? '<img src="' + playlist.thumbnail + '" alt="' + playlist.name + '">' : ''}
 <div class="library-card-badge">${playlist.trackCount} tracks</div>
 </div>
 <div class="library-card-content">
 <div class="library-card-title">${playlist.name}</div>
 <div class="library-card-meta">
 <div class="library-card-tracks">üéµ ${playlist.trackCount} songs</div>
 <div class="library-card-date">${dateStr}</div>
 </div>
 <div class="library-card-actions">
 <button class="library-add-btn" data-playlist-id="${playlist.id}">
 <span>+</span>
 <span>Add to Player</span>
 </button>
 </div>
 </div>
 `;
 
 grid.appendChild(card);
 });
 
 libraryModalBody.innerHTML = '';
 libraryModalBody.appendChild(grid);
 
 document.querySelectorAll('.library-add-btn').forEach(btn => {
 btn.addEventListener('click', (e) => {
 const playlistId = parseInt(e.currentTarget.getAttribute('data-playlist-id'));
 addFromLibrary(playlistId);
 });
 });
 }

window.addFromLibrary = function(playlistId) {
 const libraryPlaylist = playlistLibrary.find(p => p.id === playlistId);
 
 if (libraryPlaylist) {
 const newPlaylist = {
 id: Date.now(),
 name: libraryPlaylist.name,
 songs: JSON.parse(JSON.stringify(libraryPlaylist.songs)),
 youtubePlaylistId: libraryPlaylist.youtubePlaylistId
 };

 window.playlists.push(newPlaylist);
 window.currentPlaylistIndex = window.playlists.length - 1;

 window.savePlaylists();
 window.initPlaylistTabs();
 window.initPlaylist();
 window.initCarousel();

 if (newPlaylist.songs.length > 0 && window.playerReady) {
 window.selectSong(0);
 }

 window.closeLibraryModalFunc();
 
 alert(`‚úì Added "${libraryPlaylist.name}" with ${libraryPlaylist.trackCount} songs!\n\nüéâ No API calls needed - loaded from community library!`);
 }
 }

 // Library Pagination Functions
window.loadLibraryPage = function(page) {
 libraryCurrentPage = page;

 // Check cache first
 if (libraryPageCache[page]) {
 renderLibraryPage(libraryPageCache[page]);
 return;
 }

 // Show skeleton loading
 showLibrarySkeleton();

 // Simulate API delay for smooth transition
 setTimeout(() => {
 const filteredPlaylists = librarySearchQuery
 ? playlistLibrary.filter(p =>
 p.name.toLowerCase().includes(librarySearchQuery.toLowerCase()) ||
 (p.tags && p.tags.some(tag => tag.toLowerCase().includes(librarySearchQuery.toLowerCase())))
 )
 : playlistLibrary;

 libraryTotalPages = Math.ceil(filteredPlaylists.length / libraryPageSize);
 const start = (page - 1) * libraryPageSize;
 const end = start + libraryPageSize;
 const pageData = filteredPlaylists.slice(start, end);

 // Cache the page
 libraryPageCache[page] = {
 playlists: pageData,
 total: filteredPlaylists.length
 };

 renderLibraryPage(libraryPageCache[page]);
 }, 300);
 }

window.showLibrarySkeleton = function() {
 const skeleton = document.createElement('div');
 skeleton.className = 'library-skeleton';

 for (let i = 0; i < libraryPageSize; i++) {
 const card = document.createElement('div');
 card.className = 'library-skeleton-card';
 card.innerHTML = `
 <div class="library-skeleton-image"></div>
 <div class="library-skeleton-content">
 <div class="library-skeleton-title"></div>
 <div class="library-skeleton-text"></div>
 <div class="library-skeleton-text"></div>
 </div>
 `;
 skeleton.appendChild(card);
 }

 libraryModalBody.classList.add('library-fade-out');
 setTimeout(() => {
 libraryModalBody.innerHTML = '';
 libraryModalBody.appendChild(skeleton);
 libraryModalBody.classList.remove('library-fade-out');
 libraryModalBody.classList.add('library-fade-in');
 }, 150);
 }

window.renderLibraryPage = function(pageData) {
 if (pageData.playlists.length === 0) {
 libraryModalBody.innerHTML = `
 <div class="library-empty">
 <div class="library-empty-icon">üîç</div>
 <div class="library-empty-text">
 ${librarySearchQuery ? 'No playlists found matching "' + librarySearchQuery + '"' : 'No playlists available'}
 </div>
 </div>
 `;
 renderPagination(0);
 return;
 }

 const grid = document.createElement('div');
 grid.className = 'library-grid';

 pageData.playlists.forEach(playlist => {
 const card = document.createElement('div');
 card.className = 'library-card';

 const date = new Date(playlist.dateAdded);
 const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

 card.innerHTML = `
 <div class="library-card-image">
 ${playlist.thumbnail ? '<img src="' + playlist.thumbnail + '" alt="' + playlist.name + '">' : ''}
 <div class="library-card-badge">${playlist.trackCount} tracks</div>
 </div>
 <div class="library-card-content">
 <div class="library-card-title">${playlist.name}</div>
 <div class="library-card-meta">
 <div class="library-card-tracks">üéµ ${playlist.trackCount} songs</div>
 <div class="library-card-date">${dateStr}</div>
 </div>
 <div class="library-card-actions">
 <button class="library-add-btn" data-playlist-id="${playlist.id}">
 <span>+</span>
 <span>Add to Player</span>
 </button>
 </div>
 </div>
 `;

 grid.appendChild(card);
 });

 libraryModalBody.classList.add('library-fade-out');
 setTimeout(() => {
 libraryModalBody.innerHTML = '';
 libraryModalBody.appendChild(grid);
 libraryModalBody.classList.remove('library-fade-out');
 libraryModalBody.classList.add('library-fade-in');

 document.querySelectorAll('.library-add-btn').forEach(btn => {
 btn.addEventListener('click', (e) => {
 const playlistId = parseInt(e.currentTarget.getAttribute('data-playlist-id'));
 addFromLibrary(playlistId);
 });
 });
 }, 150);

 renderPagination(pageData.total);
 }

window.renderPagination = function(totalItems) {
 if (totalItems === 0) {
 libraryPaginationTop.innerHTML = '';
 libraryPaginationBottom.innerHTML = '';
 return;
 }

 const totalPages = Math.ceil(totalItems / libraryPageSize);
 const startItem = ((libraryCurrentPage - 1) * libraryPageSize) + 1;
 const endItem = Math.min(libraryCurrentPage * libraryPageSize, totalItems);

 let paginationHTML = '';

 // Previous button
 paginationHTML += `<button class="library-pagination-btn" ${libraryCurrentPage === 1 ? 'disabled' : ''} data-page="${libraryCurrentPage - 1}">‚Üê Prev</button>`;

 // Page numbers
 if (totalPages <= 7) {
 // Show all pages
 for (let i = 1; i <= totalPages; i++) {
 paginationHTML += `<button class="library-pagination-btn ${i === libraryCurrentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
 }
 } else {
 // Show first, last, and pages around current
 paginationHTML += `<button class="library-pagination-btn ${1 === libraryCurrentPage ? 'active' : ''}" data-page="1">1</button>`;

 if (libraryCurrentPage > 3) {
 paginationHTML += `<span class="library-pagination-btn dots">...</span>`;
 }

 const start = Math.max(2, libraryCurrentPage - 1);
 const end = Math.min(totalPages - 1, libraryCurrentPage + 1);

 for (let i = start; i <= end; i++) {
 paginationHTML += `<button class="library-pagination-btn ${i === libraryCurrentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
 }

 if (libraryCurrentPage < totalPages - 2) {
 paginationHTML += `<span class="library-pagination-btn dots">...</span>`;
 }

 paginationHTML += `<button class="library-pagination-btn ${totalPages === libraryCurrentPage ? 'active' : ''}" data-page="${totalPages}">${totalPages}</button>`;
 }

 // Next button
 paginationHTML += `<button class="library-pagination-btn" ${libraryCurrentPage === totalPages ? 'disabled' : ''} data-page="${libraryCurrentPage + 1}">Next ‚Üí</button>`;

 // Info
 paginationHTML += `<span class="library-pagination-info">Showing ${startItem}-${endItem} of ${totalItems}</span>`;

 libraryPaginationTop.innerHTML = paginationHTML;
 libraryPaginationBottom.innerHTML = paginationHTML;

 // Add click handlers
 document.querySelectorAll('.library-pagination-btn:not(.dots)').forEach(btn => {
 btn.addEventListener('click', (e) => {
 const page = parseInt(e.target.getAttribute('data-page'));
 if (page && !isNaN(page)) {
 loadLibraryPage(page);
 }
 });
 });
 }

 // Search functionality
window.handleLibrarySearch = function() {
 librarySearchQuery = librarySearchInput.value.trim();
 libraryCurrentPage = 1;
 libraryPageCache = {};
 librarySearchPreview.classList.remove('active');
 loadLibraryPage(1);
 }

window.handleLiveSearch = function() {
 clearTimeout(librarySearchTimeout);
 const query = librarySearchInput.value.trim().toLowerCase();

 if (query.length < 2) {
 librarySearchPreview.classList.remove('active');
 return;
 }

 librarySearchTimeout = setTimeout(() => {
 const matches = playlistLibrary
 .filter(p =>
 p.name.toLowerCase().includes(query) ||
 (p.tags && p.tags.some(tag => tag.toLowerCase().includes(query)))
 )
 .slice(0, 5);

 if (matches.length > 0) {
 let previewHTML = '';
 matches.forEach(p => {
 previewHTML += `
 <div class="library-search-preview-item" data-playlist-id="${p.id}">
 <div class="library-search-preview-title">${p.name}</div>
 <div class="library-search-preview-info">${p.trackCount} tracks</div>
 </div>
 `;
 });
 librarySearchPreview.innerHTML = previewHTML;
 librarySearchPreview.classList.add('active');

 document.querySelectorAll('.library-search-preview-item').forEach(item => {
 item.addEventListener('click', (e) => {
 const playlistId = parseInt(e.currentTarget.getAttribute('data-playlist-id'));
 addFromLibrary(playlistId);
 });
 });
 } else {
 librarySearchPreview.innerHTML = '<div class="library-search-preview-empty">No matches found</div>';
 librarySearchPreview.classList.add('active');
 }
 }, 300);
 }
}); // End DOMContentLoaded
</script>
